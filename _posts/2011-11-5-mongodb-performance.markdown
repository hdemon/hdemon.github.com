---
layout: post
style: text
title: "MongoDB+RubyでJOIN的な事をすると、どんな場合にどんな問題が起きるのか。"
---

*お断り*

+ 以下の記事は、公式のRubyドライバを使うとそうなる、という話です。
+ Rubyにおいても、もっと上手いやり方があるかもしれません。
+ 独断的に書いていますが、MongoDBを使い始めてまだ日が浅いので、全般的に知識が間違っている可能性があります。その場合はごめんなさい。そしてそっと教えて下さい。


<br>

#ヤバイ。レスポンス性能ヤバイ。

 先日、頑張って[こういうサイト](http://ynn.hdemon.net/rank/)の試験的公開にこぎつけたんだけれども、**レスポンス性能が0.5res/secを切っていた。**
 ヤバイ。
 
#何がヤバイのか

そこでまず、MongoDBのクエリがまずいんじゃないかと疑った。**結果的に最もヤバイのはRailsのView構築コスト**だったんだけど、クエリもそれなりに問題点があった。今日はそのクエリの部分の話。そして最初に結論を簡単に言うと、

+ MongoDBは、RDBMSにおけるJOIN的なこと=「参照」をすると、パフォーマンスが悪くなる。
+ ただし、それはRubyドライバ特有の問題かもしれない。
+ 参照を使わないと、保守性と拡張性が悪くなる。
+ ランキングサイトのように、1ページで多数のクエリを投げるような構造の場合、これらの問題が顕在化する。

という話。

#そもそもMongoDBって、どういうデータベースなんだ。

MongoDBは流行のNoSQLと呼ばれるものの一つで、データをJSON的なドキュメントとして管理できる。つまり、階層化することもできるし、ドキュメントごとにスキームが違っても構わない。findとかupdateとかinsertとか、直観的で分かりやすいクエリが使える。そういうDB。…だと思う。

ただしリレーション機能はRDBMS程ではなく、一応ヘルパー的なものは存在するが、基本的には自分でコレクションを組合せるスクリプトを書く必要がある。コレクションとはRDBMSにおけるテーブルのようなもの。

そして、このコレクションを分割するのか、それとも重複があったとしても全部合体させるべきなのかという問題が今回の焦点である。

#コレクションは、なるべく「埋め込む」事が推奨されている。

コレクションを分割し、**JOIN的操作を（スクリプト側で）行うことを「参照」(reference)**といい、参照を使わずに済むように、**データを階層化してぶら下げることを「埋め込み」(embedding)**と、MongoDBでは呼んでいる。

例えば、名前コレクションと住所コレクションを用意して、名前コレクションから住所コレクションのIDとか何かに紐付けを行うのが参照で、名前コレクションの個々の住所プロパティの下に住所プロパティを配置してしまうのが埋め込み。

{% highlight javascript %}
# 1つのコレクションで名前と住所を管理
  { _id: 1, name: A, adress: ... }
  { _id: 2, name: B, adress: ... }
  ... 

# 2つを分割
  # 名前コレクション
  { _id: 1, name: A, adress_id: ... }
  { _id: 2, name: B, adress_id: ... }
  ...

  # 住所コレクション
  { _id: 1, adress: { state: ..., city: ... } ...
  { _id: 2, adress: { state: ..., city: ... } ...
  ...
{% endhighlight %}

そして、[オフィシャルのこの解説](http://diigo.com/0kwog)によれば、できるだけ埋め込みでやれとある。その理由は単純に「参照は遅いから」であり、結論として、**「多対多のようなリレーションは参照にすべき」だが、それ以外の場合は埋め込みでいいと思うよ**、とも言っている。

#参照が使えないと不便なんだけど…そんなに遅いの？

多対多のリレーションが必要な場合でも、埋め込み型のスキーマにするのは自由だし、その方が一般的にはパフォーマンスは上がる。が、当然RDBMSのテーブルを正規化しない場合と似た弊害が生まれるし、ドキュメントやスキーマの変更はRDBMSよりも面倒だと思う。変更のためのイテレータだらけのスクリプトを作らなければならないから。

だから適宜参照を使うことになるわけだけど、確かにオフィシャルが言う通り、**場合によっては参照はとても問題になるぐらい遅いと思う。**それを実験で示してみたい。

まず、rootコレクションにこんなドキュメントたちを作ってみる。

{% highlight javascript %}
#参照DB rootコレクション
{ "_id" : 1, "content_id" : [ 323, 542, 881 ] }
{ "_id" : 2, "content_id" : [ 266, 356, 681 ] }
{ "_id" : 3, "content_id" : [ 727, 675, 138 ] }
...
{ "_id" : 1000, "content" : [ 10, 687, 934 ] }
{% endhighlight %}

content_idは1000までの範囲での乱数とし、これを次のcontentコレクションに紐付けるために使う。contentコレクションは次のように作った。

{% highlight javascript %}
#参照DB contentコレクション
{ "_id" : 1, "value_a" : 1305, "value_b" : 1530, "value_c" : 4757 }
{ "_id" : 2, "value_a" : 2573, "value_b" : 8782, "value_c" : 2425 }
{ "_id" : 3, "value_a" : 1572, "value_b" : 6250, "value_c" : 967 }
...
{ "_id" : 1000, "value_a" : 4738, "value_b" : 3530, "value_c" : 5689 }
{% endhighlight %}

こっちも1000個作った。valueも乱数だが、これは体裁のためで特に意味はない。この2つのコレクションのセットを、「参照DB」と呼ぶことにする。

一方で、

{% highlight javascript %}
#埋め込みDB
{ 
  "_id" : 1, "content" : [
    { "value_a" : 2898, "value_b" : 9750, "value_c" : 7473 },
    { "value_a" : 469,  "value_b" : 1603, "value_c" : 619  },
    { "value_a" : 1856, "value_b" : 9244, "value_c" : 2354 } ]
},
...
{ 
  "_id" : 1000, "content" : [ ...
{% endhighlight %}

こういう埋め込み式のコレクションも作った。これを「埋め込みDB」と呼ぶことにする。この2つのDBに対して、全てのrootドキュメントについて、紐付けられたvalue_a/b/cを取得して配列として返すロジックを実行し、その実行時間を比べてみる。

##参照DB

参照DBを、こういうスクリプトで実行してみる。なお、今回はMongoDB 2.0.1と、Ruby 1.9.2を使っている。

{% highlight ruby %}
require 'mongo'
db = Mongo::Connection.new.db("reference") # 参照DB

# rootコレクションから全てのドキュメントを取り出し、
array = db["root"].find().map do |root|
  root["content"] = root["content_id"].map do |id|
    # content_idを使って、contentコレクションを参照する。
    db["content"].find_one({"_id" => id})
  end
  root
end
# 全ての結果を、arrayに入れる。
# すると、こんな結果が帰ってくる。
# [{"_id"=>1, 
#   "content_id"=>[518, 89, 99], 
#   "content"=>[{"_id"=>518, "value_a"=>8052, ... 
{% endhighlight %}

つまり簡易JOINスクリプト。こんなスクリプトを、ruby-profで解析してみる（見やすいように、少し結果を編集してある）。そうすると、

{% highlight javascript %}
Total: 2.377599

 %self     total     self     calls  name
  8.21      0.20     0.20     14002  IO#read
  5.75      0.14     0.14      3003  BasicSocket#send
  5.48      0.15     0.13        63  Kernel#gem_original_require
  5.12      0.18     0.12      3002  Mongo::Cursor#initialize
  3.85      0.13     0.09     10003  BSON::ByteBuffer#initialize
  3.40      0.91     0.08     15012  Mutex#synchronize
  3.00      0.15     0.07      3002  Mongo::Collection#initialize
  2.84      0.30     0.07      3001  Mongo::Collection#find
  2.24      0.11     0.05      9008  BSON::ByteBuffer#put_binary
  2.19      0.28     0.05     14002  Mongo::Connection#receive_data
  2.03      0.51     0.05     19052  Class#new
  1.77      2.12     0.04      1004  Array#map <==== ここ！
  1.75      0.27     0.04      3003  Mongo::Connection#read_documents
  ...
{% endhighlight %}

と、こんな感じになる。イテレータの部分だけの処理時間は約2.1秒だった(Array#mapのtotal。totalは、そのメソッドとメソッドが呼び出した処理の全体の実行時間を示す)。ちなみに、contentコレクションの_idにはインデックスが張られている。

また、こんな風に適当に参照をもう1つ増やすと(出力にとっては意味が無いけど)、

{% highlight ruby %}
array = db["root"].find().map do |root|
  root["content"] = root["content_id"].map do |id|
    db["content"].find_one({"_id" => id})
    db["content"].find_one({"_id" => id})
  end
  root
end
{% endhighlight %}

{% highlight javascript %}
Total: 4.780326

 %self     total     self     wait    child    calls  name
 14.41      0.69     0.69     25996  IO#read
  6.75      0.32     0.32      6003  BasicSocket#send
  4.66      0.34     0.22      6002  Mongo::Cursor#initialize
  3.37      0.22     0.16     19000  BSON::ByteBuffer#initialize
  3.34      2.10     0.16     30012  Mutex#synchronize
  2.90      0.16     0.14        63  Kernel#gem_original_require
  2.73      0.29     0.13      6002  Mongo::Collection#initialize
  2.67      0.57     0.13      6001  Mongo::Collection#find
  2.32      0.24     0.11     18008  BSON::ByteBuffer#put_binary
  2.14      0.98     0.10     37049  Class#new
  ...
  1.02      4.52     0.05      1004  Array#map
  ...
{% endhighlight %}

順当に約2倍の時間がかかる。つまり、mapメソッドのコストはそもそも大したものじゃなく、個々のクエリ毎に固定したコストが積み上がり、共通処理のようなもの―例えば一旦作ったオブジェクトを共有するとか―が少ないんだろうと想像できる(selfはそれ単体の実行時間)。

なお、[DBRefという参照のためのヘルパーが存在し](http://www.mongodb.org/display/DOCSJP/database+reference)、もしかしたら内部的に最適化がされていたりして、これを使うと参照が速くなるのかもしれない…と思ったが、少なくともRubyドライバの[ソース](http://api.mongodb.org/ruby/current/Mongo/DB.html#dereference-instance_method)を読む限りでは、**内部でfind_oneするだけのラッパーのようだった。**オブジェクトを生成する分余計に遅くなるので、今回はDBRefを使ってない。
<br>
##埋め込みDB

じゃあ、「埋め込み」方式だったらどうなのか。

{% highlight ruby %}
require 'mongo'
db = Mongo::Connection.new.db("embed")

array = db["root"].find().to_a
{% endhighlight %}

{% highlight javascript %}
Total: 0.285815

 %self     total     self     wait    child    calls  name
 44.86      0.15     0.13     0.00     0.15       63  Kernel#gem_original_require
 21.90      0.06     0.06     0.00     0.00        2  TCPSocket#initialize
  3.27      0.01     0.01     0.00     0.00        1  OpenSSL::X509::Store#set_default_paths
  2.50      0.01     0.01     0.00     0.00    11499  Hash#default
  2.32      0.01     0.01     0.00     0.00     2007  <Class::Hash>#allocate
  2.19      0.02     0.01     0.00     0.01     2008  Mongo::Connection#receive_data
  2.04      0.01     0.01     0.00     0.00     1006  BSON::ByteBuffer#initialize
  1.90      0.01     0.01     0.00     0.00     2008  IO#read
  1.84      0.06     0.01     0.00     0.05        3  Mongo::Connection#read_documents
  ...
  0.65      0.07     0.00     0.00     0.06     1055  Class#new
  ...
  0.14      0.00     0.00     0.00     0.00        3  BasicSocket#send
  ...
  0.00      0.07     0.00     0.00     0.07        1  Enumerable#to_a
  ...
{% endhighlight %}

全て埋め込んであるので、valueを含んだハッシュオブジェクトの配列が欲しければ、Enumerableオブジェクトとして帰ってきた結果をto_aすればいい。その結果、全体として0.28秒だが内0.15秒はrequire(1位のtotal)だから、大体0.13秒以内に終わっていることになる。
何がこんなに違いを生むのか。プロファイリングをよく読むと、こういうところに違いが出ている。

{% highlight javascript %}
参照DB + 2つの参照
 %self     total     self     calls  name
  6.75      0.32     0.32      6003  BasicSocket#send
  4.66      0.34     0.22      6002  Mongo::Cursor#initialize

埋め込みDB
  0.05      0.00     0.00         3  BasicSocket#send  
  0.04      0.00     0.00         2  Mongo::Cursor#initialize

{% endhighlight %}

どうも、ソケットとのやりとりとMongoDBのオブジェクト等の用意に時間がかかるらしい。これだけだと大した累積にならないように思えるが(selfの部分)、上の結果はほんの一部であり、このあと延々と微細なメソッドが続く。参照DBでは同じように6000回実行されるものが沢山あるので、この初期化と通信の周辺処理のようなものなんだろうと思う。


#まとめ―結局どんな場合に問題になるのか。

**…いやまて、そもそもこんなクエリどこで使うんだ**、というツッコミがここで想像できる。

確かに、普通に何かのお気に入り機能＋マイページ等ならば、アクセス毎に1000回のイテレーションを行ったりするのは正気の沙汰じゃないと思う。

でも、僕が今運営しているのはランキングサイトで、一つ一つのランキング対象のマイリストについてリレーションを調べなきゃいけない。1000個/ページはさすがにおかしいにしても、ランキングなので100位までは1ページに表示させている。

そして、ランキングについては事前に計算済みのコレクションを作っておくという事もできるし、Railsにキャッシュさせることもできるが、検索ページではそうもいかない。検索ページも100個/ページの設計だが、この検索結果表示数を減らすぐらいしか、参照方式を維持したままパフォーマンスを上げる本質的な解決方法はないと思う(RailsのFragmentキャッシュを使えばいいのかもしれないけど、試してないので何とも言えない)。

<br>
…と言う訳で、最初に書いたまとめにもう少し付け加えて、最終的なまとめを書いてみる。

> MongoDBは、RDBMSにおけるJOIN的なこと=「参照」をすると、パフォーマンスが悪くなる。

MongoDBのRubyドライバにおいては、オブジェクトの初期化やソケット通信が実行時間の多くを占める。したがって、**実行時間はクエリの質と同時に数にも大きく影響を受け**、それゆえインデックスを適切に張ることでは解決しないことがある。でも、[こういうやり方](http://fungoing.jp/2011/09/426/)もあるのかもしれない。素晴らしい発想！

> ただし、それはRubyドライバ特有の問題かもしれない。

MongoDBのカーソル等のオブジェクトの初期化に時間がかかるのが、RubyのせいなのかMongoDB自体の重さゆえなのかは僕には分からない。ただ、MongoDBは参照を内部的に処理するロジックを持っていないので、言語側がそれを代替せざるを得ず、言語の重さが反映されやすいのは確かだと思う。

そして、Rubyがそれを現実的に問題になるレベルに引き上げているのかもしれない。他の言語のドライバなら、オブジェクト初期化やソケットとのやりとりが軽い場合もあるのかもしれない。僕はRubyとJavaScriptしか知らないので、そのへんは分からない。

> 参照を使わないと、保守性と拡張性が悪くなる。

参照を使わない=埋め込み方式のスキーマを採用するとき、速度の問題はとりあえずなくなるが（あんまり巨大なコレクションだと、それはそれで問題かもしれない）、保守性・拡張性が悪くなるという問題と、容量の問題が生まれる。

保守性と拡張性が悪くなるというのは、具体的には**スキーマ変更や値の整合性検査用のスクリプトが複雑化するということ**ということ。一見SQLより楽そうだが、スキーマが自由であるがゆえに、nilなどが予期せず混入していたり、あるはずのキーがなかったりして、イテレータと分岐だらけのスクリプトになる可能性がある。ただ、これはインサート時に適切なマッパーを使ってvalidateするなどで対応できるかもしれない。

容量の問題も結構重要で、実は[ドキュメント毎の容量が16MBという制限](http://www.mongodb.org/display/DOCS/Documents)がある様子。僕は毎日のログを埋め込みにして追記していたが、いつか上限に引っかかるかもしれない。

> ランキングサイトのように、1ページで多数のクエリを投げるような構造の場合、これらの問題が顕在化する。

これがこの記事の結論で、具体的には**1アクセス毎に数十個超のクエリを投げ、その結果がキャッシュできないページの場合や、集計等のバッチ処理が問題になると思う。**クエリの質よりも数が、RDBMSに比べて問題になりやすいと言い換えてもいいかもしれない。

例えばクックパッドのように、ある人のある料理を表示し、自分のお気に入りの情報を表示し、ちょこっとランキングを乗せる程度なら問題にならないと思う。リレーションを含めた全体のクエリの個数も限られるから。でも、「対象を固定しない100個の要素を表示して、任意に並び替えができる検索結果ページ」なんてことになると、キャッシュもできず問題があらわになる。僕のサイトで参照方式と埋め込み方式の比較を行ったところ、5~8倍程度の実行時間の差が出てしまった。

また、集計などのバッチ処理をRubyでしようと思ったら、もうこの問題は避けられない。僕は毎晩4万件超を対象にしたバッチ処理を行なっているが、**数千の処理ごとに数分間沈黙する。**たぶん、GCがメルトダウンするぐらい仕事してるんだと思う。

ただ、集計に関してはバルクインサートを上手く使えばいいのかもしれない。また、MongoDBにJavaScriptを読み込ませて実行すれば、また結果は違うのかも知れない。ここらへんも実験してないので分からない。

> でもやっぱりMongoDBかわいいよMongoDB

そうは言っても、MongoDBはとっつきやすいし、JSONっぽく操れて楽しいよ！

