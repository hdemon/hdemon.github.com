<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>MongoDB+RubyでJOIN的な事をすると、どんな場合にどんな問題が起きるのか。 </title>

  <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css" media="screen" />

  <!-- web font -->
  <link href='http://fonts.googleapis.com/css?family=Maven+Pro:700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" type="text/css" href="/vendor/highlight/styles/sunburst.css" media="screen" />

</head>

<body>
  <header>
    <div>
      <div id="title-band"></div>
      <div id="title-logo" class="sprites index-titlelogo">
        <a href="/"></a>
      </div>
      <div id="title-icon" class="sprites index-titleicon">
        <a href="/"></a>
      </div>
      <ul>
        <li>twitter: <a href="https://twitter.com/#!/h_demon">@h_demon</a></li>
        <li>mail: hdemon7@gmail.com</li>
        <li>GitHub: <a href="https://github.com/hdemon">https://github.com/hdemon</a></li>
      </ul>
    </div>
  </header>

  <div id="each-article">
    <article>
      <header>
        <h1>
          MongoDB+RubyでJOIN的な事をすると、どんな場合にどんな問題が起きるのか。
        </h1>
        <span id="date">
          05 November 2011
        </span>
      </header>
    <p><em>お断り</em></p>

<ul>
<li>以下の記事は、公式のRubyドライバを使うとそうなる、という話です。</li>
<li>Rubyにおいても、もっと上手いやり方があるかもしれません。</li>
<li>独断的に書いていますが、MongoDBを使い始めてまだ日が浅いので、全般的に知識が間違っている可能性があります。その場合はごめんなさい。そしてそっと教えて下さい。</li>
</ul>


<br>


<h1>ヤバイ。レスポンス性能ヤバイ。</h1>

<p> 先日、頑張って<a href="http://ynn.hdemon.net/rank/">こういうサイト</a>の試験的公開にこぎつけたんだけれども、<strong>レスポンス性能が0.5res/secを切っていた。</strong>
 ヤバイ。</p>

<h1>何がヤバイのか</h1>

<p>そこでまず、MongoDBのクエリがまずいんじゃないかと疑った。<strong>結果的に最もヤバイのはRailsのView構築コスト</strong>だったんだけど、クエリもそれなりに問題点があった。今日はそのクエリの部分の話。そして最初に結論を簡単に言うと、</p>

<ul>
<li>MongoDBは、RDBMSにおけるJOIN的なこと=「参照」をすると、パフォーマンスが悪くなる。</li>
<li>ただし、それはRubyドライバ特有の問題かもしれない。</li>
<li>参照を使わないと、保守性と拡張性が悪くなる。</li>
<li>ランキングサイトのように、1ページで多数のクエリを投げるような構造の場合、これらの問題が顕在化する。</li>
</ul>


<p>という話。</p>

<h1>そもそもMongoDBって、どういうデータベースなんだ。</h1>

<p>MongoDBは流行のNoSQLと呼ばれるものの一つで、データをJSON的なドキュメントとして管理できる。つまり、階層化することもできるし、ドキュメントごとにスキームが違っても構わない。findとかupdateとかinsertとか、直観的で分かりやすいクエリが使える。そういうDB。…だと思う。</p>

<p>ただしリレーション機能はRDBMS程ではなく、一応ヘルパー的なものは存在するが、基本的には自分でコレクションを組合せるスクリプトを書く必要がある。コレクションとはRDBMSにおけるテーブルのようなもの。</p>

<p>そして、このコレクションを分割するのか、それとも重複があったとしても全部合体させるべきなのかという問題が今回の焦点である。</p>

<h1>コレクションは、なるべく「埋め込む」事が推奨されている。</h1>

<p>コレクションを分割し、<strong>JOIN的操作を（スクリプト側で）行うことを「参照」(reference)</strong>といい、参照を使わずに済むように、<strong>データを階層化してぶら下げることを「埋め込み」(embedding)</strong>と、MongoDBでは呼んでいる。</p>

<p>例えば、名前コレクションと住所コレクションを用意して、名前コレクションから住所コレクションのIDとか何かに紐付けを行うのが参照で、名前コレクションの個々の住所プロパティの下に住所プロパティを配置してしまうのが埋め込み。</p>

<div class="highlight"><pre><code class="javascript"><span class="err">#</span> <span class="mi">1</span><span class="err">つのコレクションで名前と住所を管理</span>
  <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">adress</span><span class="o">:</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">adress</span><span class="o">:</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">...</span> 

<span class="err">#</span> <span class="mi">2</span><span class="err">つを分割</span>
  <span class="err">#</span> <span class="err">名前コレクション</span>
  <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">adress_id</span><span class="o">:</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">adress_id</span><span class="o">:</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">...</span>

  <span class="err">#</span> <span class="err">住所コレクション</span>
  <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">adress</span><span class="o">:</span> <span class="p">{</span> <span class="nx">state</span><span class="o">:</span> <span class="p">...,</span> <span class="nx">city</span><span class="o">:</span> <span class="p">...</span> <span class="p">}</span> <span class="p">...</span>
  <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">adress</span><span class="o">:</span> <span class="p">{</span> <span class="nx">state</span><span class="o">:</span> <span class="p">...,</span> <span class="nx">city</span><span class="o">:</span> <span class="p">...</span> <span class="p">}</span> <span class="p">...</span>
  <span class="p">...</span>
</code></pre>
</div>


<p>そして、<a href="http://diigo.com/0kwog">オフィシャルのこの解説</a>によれば、できるだけ埋め込みでやれとある。その理由は単純に「参照は遅いから」であり、結論として、<strong>「多対多のようなリレーションは参照にすべき」だが、それ以外の場合は埋め込みでいいと思うよ</strong>、とも言っている。</p>

<h1>参照が使えないと不便なんだけど…そんなに遅いの？</h1>

<p>多対多のリレーションが必要な場合でも、埋め込み型のスキーマにするのは自由だし、その方が一般的にはパフォーマンスは上がる。が、当然RDBMSのテーブルを正規化しない場合と似た弊害が生まれるので参照を使いたくなる。それに多対多でなくとも、そもそもMongoDBはスキーマの変更がRDBMSよりも面倒なので、やはり適宜参照を使ってスキーマをシンプルに保ちたくなる。</p>

<p>しかし、確かにオフィシャルが言う通り、<strong>場合によっては参照はとても問題になるぐらい遅いと思う。</strong>それを実験で示してみたい。</p>

<p>まず、rootコレクションにこんなドキュメントたちを作ってみる。</p>

<div class="highlight"><pre><code class="javascript"><span class="err">#参照</span><span class="nx">DB</span> <span class="nx">root</span><span class="err">コレクション</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;content_id&quot;</span> <span class="o">:</span> <span class="p">[</span> <span class="mi">323</span><span class="p">,</span> <span class="mi">542</span><span class="p">,</span> <span class="mi">881</span> <span class="p">]</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;content_id&quot;</span> <span class="o">:</span> <span class="p">[</span> <span class="mi">266</span><span class="p">,</span> <span class="mi">356</span><span class="p">,</span> <span class="mi">681</span> <span class="p">]</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;content_id&quot;</span> <span class="o">:</span> <span class="p">[</span> <span class="mi">727</span><span class="p">,</span> <span class="mi">675</span><span class="p">,</span> <span class="mi">138</span> <span class="p">]</span> <span class="p">}</span>
<span class="p">...</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;content&quot;</span> <span class="o">:</span> <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">934</span> <span class="p">]</span> <span class="p">}</span>
</code></pre>
</div>


<p>content_idは1000までの範囲での乱数とし、これを次のcontentコレクションに紐付けるために使う。contentコレクションは次のように作った。</p>

<div class="highlight"><pre><code class="javascript"><span class="err">#参照</span><span class="nx">DB</span> <span class="nx">content</span><span class="err">コレクション</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">1305</span><span class="p">,</span> <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">1530</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">4757</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">2573</span><span class="p">,</span> <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">8782</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">2425</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">1572</span><span class="p">,</span> <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">6250</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">967</span> <span class="p">}</span>
<span class="p">...</span>
<span class="p">{</span> <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">4738</span><span class="p">,</span> <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">3530</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">5689</span> <span class="p">}</span>
</code></pre>
</div>


<p>こっちも1000個作った。valueも乱数だが、これは体裁のためで特に意味はない。この2つのコレクションのセットを、「参照DB」と呼ぶことにする。</p>

<p>一方で、</p>

<div class="highlight"><pre><code class="javascript"><span class="err">#埋め込み</span><span class="nx">DB</span>
<span class="p">{</span> 
  <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;content&quot;</span> <span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">2898</span><span class="p">,</span> <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">9750</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">7473</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">469</span><span class="p">,</span>  <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">1603</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">619</span>  <span class="p">},</span>
    <span class="p">{</span> <span class="s2">&quot;value_a&quot;</span> <span class="o">:</span> <span class="mi">1856</span><span class="p">,</span> <span class="s2">&quot;value_b&quot;</span> <span class="o">:</span> <span class="mi">9244</span><span class="p">,</span> <span class="s2">&quot;value_c&quot;</span> <span class="o">:</span> <span class="mi">2354</span> <span class="p">}</span> <span class="p">]</span>
<span class="p">},</span>
<span class="p">...</span>
<span class="p">{</span> 
  <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;content&quot;</span> <span class="o">:</span> <span class="p">[</span> <span class="p">...</span>
</code></pre>
</div>


<p>こういう埋め込み式のコレクションも作った。これを「埋め込みDB」と呼ぶことにする。この2つのDBに対して、全てのrootドキュメントについて、紐付けられたvalue_a/b/cを取得して配列として返すロジックを実行し、その実行時間を比べてみる。</p>

<h2>参照DB</h2>

<p>参照DBを、こういうスクリプトで実行してみる。なお、今回はMongoDB 2.0.1と、Ruby 1.9.2を使っている。</p>

<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;mongo&#39;</span>
<span class="n">db</span> <span class="o">=</span> <span class="no">Mongo</span><span class="o">::</span><span class="no">Connection</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">db</span><span class="p">(</span><span class="s2">&quot;reference&quot;</span><span class="p">)</span> <span class="c1"># 参照DB</span>

<span class="c1"># rootコレクションから全てのドキュメントを取り出し、</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">db</span><span class="o">[</span><span class="s2">&quot;root&quot;</span><span class="o">].</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">root</span><span class="o">|</span>
  <span class="n">root</span><span class="o">[</span><span class="s2">&quot;content&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">[</span><span class="s2">&quot;content_id&quot;</span><span class="o">].</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="o">|</span>
    <span class="c1"># content_idを使って、contentコレクションを参照する。</span>
    <span class="n">db</span><span class="o">[</span><span class="s2">&quot;content&quot;</span><span class="o">].</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span> <span class="o">=&gt;</span> <span class="nb">id</span><span class="p">})</span>
  <span class="k">end</span>
  <span class="n">root</span>
<span class="k">end</span>
<span class="c1"># 全ての結果を、arrayに入れる。</span>
<span class="c1"># すると、こんな結果が帰ってくる。</span>
<span class="c1"># [{&quot;_id&quot;=&gt;1, </span>
<span class="c1">#   &quot;content_id&quot;=&gt;[518, 89, 99], </span>
<span class="c1">#   &quot;content&quot;=&gt;[{&quot;_id&quot;=&gt;518, &quot;value_a&quot;=&gt;8052, ... </span>
</code></pre>
</div>


<p>つまり簡易JOINスクリプト。こんなスクリプトを、ruby-profで解析してみる（見やすいように、少し結果を編集してある）。そうすると、</p>

<div class="highlight"><pre><code class="javascript"><span class="nx">Total</span><span class="o">:</span> <span class="mf">2.377599</span>

 <span class="o">%</span><span class="nx">self</span>     <span class="nx">total</span>     <span class="nx">self</span>     <span class="nx">calls</span>  <span class="nx">name</span>
  <span class="mf">8.21</span>      <span class="mf">0.20</span>     <span class="mf">0.20</span>     <span class="mi">14002</span>  <span class="nx">IO</span><span class="err">#</span><span class="nx">read</span>
  <span class="mf">5.75</span>      <span class="mf">0.14</span>     <span class="mf">0.14</span>      <span class="mi">3003</span>  <span class="nx">BasicSocket</span><span class="err">#</span><span class="nx">send</span>
  <span class="mf">5.48</span>      <span class="mf">0.15</span>     <span class="mf">0.13</span>        <span class="mi">63</span>  <span class="nx">Kernel</span><span class="err">#</span><span class="nx">gem_original_require</span>
  <span class="mf">5.12</span>      <span class="mf">0.18</span>     <span class="mf">0.12</span>      <span class="mi">3002</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Cursor</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">3.85</span>      <span class="mf">0.13</span>     <span class="mf">0.09</span>     <span class="mi">10003</span>  <span class="nx">BSON</span><span class="o">::</span><span class="nx">ByteBuffer</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">3.40</span>      <span class="mf">0.91</span>     <span class="mf">0.08</span>     <span class="mi">15012</span>  <span class="nx">Mutex</span><span class="err">#</span><span class="nx">synchronize</span>
  <span class="mf">3.00</span>      <span class="mf">0.15</span>     <span class="mf">0.07</span>      <span class="mi">3002</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Collection</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">2.84</span>      <span class="mf">0.30</span>     <span class="mf">0.07</span>      <span class="mi">3001</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Collection</span><span class="err">#</span><span class="nx">find</span>
  <span class="mf">2.24</span>      <span class="mf">0.11</span>     <span class="mf">0.05</span>      <span class="mi">9008</span>  <span class="nx">BSON</span><span class="o">::</span><span class="nx">ByteBuffer</span><span class="err">#</span><span class="nx">put_binary</span>
  <span class="mf">2.19</span>      <span class="mf">0.28</span>     <span class="mf">0.05</span>     <span class="mi">14002</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Connection</span><span class="err">#</span><span class="nx">receive_data</span>
  <span class="mf">2.03</span>      <span class="mf">0.51</span>     <span class="mf">0.05</span>     <span class="mi">19052</span>  <span class="nx">Class</span><span class="err">#</span><span class="k">new</span>
  <span class="mf">1.77</span>      <span class="mf">2.12</span>     <span class="mf">0.04</span>      <span class="mi">1004</span>  <span class="nb">Array</span><span class="err">#</span><span class="nx">map</span> <span class="o">&lt;====</span> <span class="err">ここ！</span>
  <span class="mf">1.75</span>      <span class="mf">0.27</span>     <span class="mf">0.04</span>      <span class="mi">3003</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Connection</span><span class="err">#</span><span class="nx">read_documents</span>
  <span class="p">...</span>
</code></pre>
</div>


<p>と、こんな感じになる。イテレータの部分だけの処理時間は約2.1秒だった(Array#mapのtotal。totalは、そのメソッドとメソッドが呼び出した処理の全体の実行時間を示す)。ちなみに、contentコレクションの_idにはインデックスが張られている。</p>

<p>また、こんな風に適当に参照をもう1つ増やすと(出力にとっては意味が無いけど)、</p>

<div class="highlight"><pre><code class="ruby"><span class="n">array</span> <span class="o">=</span> <span class="n">db</span><span class="o">[</span><span class="s2">&quot;root&quot;</span><span class="o">].</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">root</span><span class="o">|</span>
  <span class="n">root</span><span class="o">[</span><span class="s2">&quot;content&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">[</span><span class="s2">&quot;content_id&quot;</span><span class="o">].</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="o">|</span>
    <span class="n">db</span><span class="o">[</span><span class="s2">&quot;content&quot;</span><span class="o">].</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span> <span class="o">=&gt;</span> <span class="nb">id</span><span class="p">})</span>
    <span class="n">db</span><span class="o">[</span><span class="s2">&quot;content&quot;</span><span class="o">].</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span> <span class="o">=&gt;</span> <span class="nb">id</span><span class="p">})</span>
  <span class="k">end</span>
  <span class="n">root</span>
<span class="k">end</span>
</code></pre>
</div>




<div class="highlight"><pre><code class="javascript"><span class="nx">Total</span><span class="o">:</span> <span class="mf">4.780326</span>

 <span class="o">%</span><span class="nx">self</span>     <span class="nx">total</span>     <span class="nx">self</span>     <span class="nx">calls</span>  <span class="nx">name</span>
 <span class="mf">14.41</span>      <span class="mf">0.69</span>     <span class="mf">0.69</span>     <span class="mi">25996</span>  <span class="nx">IO</span><span class="err">#</span><span class="nx">read</span>
  <span class="mf">6.75</span>      <span class="mf">0.32</span>     <span class="mf">0.32</span>      <span class="mi">6003</span>  <span class="nx">BasicSocket</span><span class="err">#</span><span class="nx">send</span>
  <span class="mf">4.66</span>      <span class="mf">0.34</span>     <span class="mf">0.22</span>      <span class="mi">6002</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Cursor</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">3.37</span>      <span class="mf">0.22</span>     <span class="mf">0.16</span>     <span class="mi">19000</span>  <span class="nx">BSON</span><span class="o">::</span><span class="nx">ByteBuffer</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">3.34</span>      <span class="mf">2.10</span>     <span class="mf">0.16</span>     <span class="mi">30012</span>  <span class="nx">Mutex</span><span class="err">#</span><span class="nx">synchronize</span>
  <span class="mf">2.90</span>      <span class="mf">0.16</span>     <span class="mf">0.14</span>        <span class="mi">63</span>  <span class="nx">Kernel</span><span class="err">#</span><span class="nx">gem_original_require</span>
  <span class="mf">2.73</span>      <span class="mf">0.29</span>     <span class="mf">0.13</span>      <span class="mi">6002</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Collection</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">2.67</span>      <span class="mf">0.57</span>     <span class="mf">0.13</span>      <span class="mi">6001</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Collection</span><span class="err">#</span><span class="nx">find</span>
  <span class="mf">2.32</span>      <span class="mf">0.24</span>     <span class="mf">0.11</span>     <span class="mi">18008</span>  <span class="nx">BSON</span><span class="o">::</span><span class="nx">ByteBuffer</span><span class="err">#</span><span class="nx">put_binary</span>
  <span class="mf">2.14</span>      <span class="mf">0.98</span>     <span class="mf">0.10</span>     <span class="mi">37049</span>  <span class="nx">Class</span><span class="err">#</span><span class="k">new</span>
  <span class="p">...</span>
  <span class="mf">1.02</span>      <span class="mf">4.52</span>     <span class="mf">0.05</span>      <span class="mi">1004</span>  <span class="nb">Array</span><span class="err">#</span><span class="nx">map</span>
  <span class="p">...</span>
</code></pre>
</div>


<p>順当に約2倍の時間がかかる。つまり、mapメソッドのコストはそもそも大したものじゃなく、個々のクエリ毎に固定したコストが積み上がり、共通処理のようなもの―例えば一旦作ったオブジェクトを共有するとか―が少ないんだろうと想像できる(selfはそれ単体の実行時間)。</p>

<p>なお、<a href="http://www.mongodb.org/display/DOCSJP/database+reference">DBRefという参照のためのヘルパーが存在し</a>、もしかしたら内部的に最適化がされていたりして、これを使うと参照が速くなるのかもしれない…と思ったが、少なくともRubyドライバの<a href="http://api.mongodb.org/ruby/current/Mongo/DB.html#dereference-instance_method">ソース</a>を読む限りでは、<strong>内部でfind_oneするだけのラッパーのようだった。</strong>オブジェクトを生成する分余計に遅くなるので、今回はDBRefを使ってない。</p>

<br>


<h2>埋め込みDB</h2>

<p>じゃあ、「埋め込み」方式だったらどうなのか。</p>

<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;mongo&#39;</span>
<span class="n">db</span> <span class="o">=</span> <span class="no">Mongo</span><span class="o">::</span><span class="no">Connection</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">db</span><span class="p">(</span><span class="s2">&quot;embed&quot;</span><span class="p">)</span>

<span class="n">array</span> <span class="o">=</span> <span class="n">db</span><span class="o">[</span><span class="s2">&quot;root&quot;</span><span class="o">].</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">to_a</span>
</code></pre>
</div>




<div class="highlight"><pre><code class="javascript"><span class="nx">Total</span><span class="o">:</span> <span class="mf">0.285815</span>

 <span class="o">%</span><span class="nx">self</span>     <span class="nx">total</span>     <span class="nx">self</span>    <span class="nx">calls</span>  <span class="nx">name</span>
 <span class="mf">44.86</span>      <span class="mf">0.15</span>     <span class="mf">0.13</span>       <span class="mi">63</span>  <span class="nx">Kernel</span><span class="err">#</span><span class="nx">gem_original_require</span>
 <span class="mf">21.90</span>      <span class="mf">0.06</span>     <span class="mf">0.06</span>        <span class="mi">2</span>  <span class="nx">TCPSocket</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">3.27</span>      <span class="mf">0.01</span>     <span class="mf">0.01</span>        <span class="mi">1</span>  <span class="nx">OpenSSL</span><span class="o">::</span><span class="nx">X509</span><span class="o">::</span><span class="nx">Store</span><span class="err">#</span><span class="nx">set_default_paths</span>
  <span class="mf">2.50</span>      <span class="mf">0.01</span>     <span class="mf">0.01</span>    <span class="mi">11499</span>  <span class="nx">Hash</span><span class="err">#</span><span class="k">default</span>
  <span class="mf">2.32</span>      <span class="mf">0.01</span>     <span class="mf">0.01</span>     <span class="mi">2007</span>  <span class="o">&lt;</span><span class="nx">Class</span><span class="o">::</span><span class="nx">Hash</span><span class="o">&gt;</span><span class="err">#</span><span class="nx">allocate</span>
  <span class="mf">2.19</span>      <span class="mf">0.02</span>     <span class="mf">0.01</span>     <span class="mi">2008</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Connection</span><span class="err">#</span><span class="nx">receive_data</span>
  <span class="mf">2.04</span>      <span class="mf">0.01</span>     <span class="mf">0.01</span>     <span class="mi">1006</span>  <span class="nx">BSON</span><span class="o">::</span><span class="nx">ByteBuffer</span><span class="err">#</span><span class="nx">initialize</span>
  <span class="mf">1.90</span>      <span class="mf">0.01</span>     <span class="mf">0.01</span>     <span class="mi">2008</span>  <span class="nx">IO</span><span class="err">#</span><span class="nx">read</span>
  <span class="mf">1.84</span>      <span class="mf">0.06</span>     <span class="mf">0.01</span>        <span class="mi">3</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Connection</span><span class="err">#</span><span class="nx">read_documents</span>
  <span class="p">...</span>
  <span class="mf">0.65</span>      <span class="mf">0.07</span>     <span class="mf">0.00</span>     <span class="mi">1055</span>  <span class="nx">Class</span><span class="err">#</span><span class="k">new</span>
  <span class="p">...</span>
  <span class="mf">0.14</span>      <span class="mf">0.00</span>     <span class="mf">0.00</span>        <span class="mi">3</span>  <span class="nx">BasicSocket</span><span class="err">#</span><span class="nx">send</span>
  <span class="p">...</span>
  <span class="mf">0.00</span>      <span class="mf">0.07</span>     <span class="mf">0.00</span>        <span class="mi">1</span>  <span class="nx">Enumerable</span><span class="err">#</span><span class="nx">to_a</span>
  <span class="p">...</span>
</code></pre>
</div>


<p>全て埋め込んであるので、valueを含んだハッシュオブジェクトの配列が欲しければ、Enumerableオブジェクトとして帰ってきた結果をto_aすればいい。その結果、全体として0.28秒だが内0.15秒はrequire(1位のtotal)だから、大体0.13秒以内に終わっていることになる。
何がこんなに違いを生むのか。プロファイリングをよく読むと、こういうところに違いが出ている。</p>

<div class="highlight"><pre><code class="javascript"><span class="err">参照</span><span class="nx">DB</span> <span class="o">+</span> <span class="mi">2</span><span class="err">つの参照</span>
 <span class="o">%</span><span class="nx">self</span>     <span class="nx">total</span>     <span class="nx">self</span>     <span class="nx">calls</span>  <span class="nx">name</span>
  <span class="mf">6.75</span>      <span class="mf">0.32</span>     <span class="mf">0.32</span>      <span class="mi">6003</span>  <span class="nx">BasicSocket</span><span class="err">#</span><span class="nx">send</span>
  <span class="mf">4.66</span>      <span class="mf">0.34</span>     <span class="mf">0.22</span>      <span class="mi">6002</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Cursor</span><span class="err">#</span><span class="nx">initialize</span>

<span class="err">埋め込み</span><span class="nx">DB</span>
  <span class="mf">0.05</span>      <span class="mf">0.00</span>     <span class="mf">0.00</span>         <span class="mi">3</span>  <span class="nx">BasicSocket</span><span class="err">#</span><span class="nx">send</span>  
  <span class="mf">0.04</span>      <span class="mf">0.00</span>     <span class="mf">0.00</span>         <span class="mi">2</span>  <span class="nx">Mongo</span><span class="o">::</span><span class="nx">Cursor</span><span class="err">#</span><span class="nx">initialize</span>
</code></pre>
</div>


<p>どうも、ソケットとのやりとりとMongoDBのオブジェクト等の用意に時間がかかるらしい。これだけだと大した累積にならないように思えるが(selfの部分)、上の結果はほんの一部であり、このあと延々と微細なメソッドが続く。参照DBでは同じように6000回実行されるものが沢山あるので、この初期化と通信の周辺処理のようなものなんだろうと思う。</p>

<h1>まとめ―結局どんな場合に問題になるのか。</h1>

<p><strong>…いやまて、そもそもこんなクエリどこで使うんだ</strong>、というツッコミがここで想像できる。</p>

<p>確かに、普通に何かのお気に入り機能＋マイページ等ならば、アクセス毎に1000回のイテレーションを行ったりするのは正気の沙汰じゃないと思う。</p>

<p>でも、僕が今運営しているのはランキングサイトで、一つ一つのランキング対象のマイリストについてリレーションを調べなきゃいけない。1000個/ページはさすがにおかしいにしても、ランキングなので100位までは1ページに表示させている。</p>

<p>そして、ランキングについては事前に計算済みのコレクションを作っておくという事もできるし、Railsにキャッシュさせることもできるが、検索ページではそうもいかない(RailsのFragmentキャッシュを使うのも…)。検索ページも100個/ページの設計だが、この検索結果表示数を減らすぐらいしか、参照方式を維持したままパフォーマンスを上げる本質的な解決方法はないと思う。</p>

<br>


<p>…と言う訳で、最初に書いたまとめにもう少し付け加えて、最終的なまとめを書いてみる。あと、「かもしれない」だらけでごめんなさい。</p>

<blockquote><p>MongoDBは、RDBMSにおけるJOIN的なこと=「参照」をすると、パフォーマンスが悪くなる。</p></blockquote>

<p>MongoDBのRubyドライバにおいては、オブジェクトの初期化やソケット通信が実行時間の多くを占める。したがって、<strong>実行時間はクエリの質と同時に数にも大きく影響を受け</strong>、それゆえインデックスを適切に張ることでは解決しないことがある。でも、<a href="http://fungoing.jp/2011/09/426/">こういうやり方</a>もあるらしい。素晴らしい発想！</p>

<blockquote><p>ただし、それはRubyドライバ特有の問題かもしれない。</p></blockquote>

<p>MongoDBのカーソル等のオブジェクトの初期化に時間がかかるのが、RubyのせいなのかMongoDB自体の重さゆえなのかは僕には分からない。ただ、MongoDBは参照を内部的に処理するロジックを持っていないので、言語側がそれを代替せざるを得ず、言語の重さが反映されやすいのは確かだと思う。</p>

<p>そして、Rubyがそれを現実的に問題になるレベルに引き上げている可能性はある。他の言語のドライバなら、オブジェクト初期化やソケットとのやりとりが軽い場合もあるのかもしれない。もちろん反対の可能性も。</p>

<blockquote><p>参照を使わないと、保守性と拡張性が悪くなる。</p></blockquote>

<p>参照を使わない=埋め込み方式のスキーマを採用するとき、速度の問題はとりあえずなくなるが（あんまり巨大なコレクションだと、それはそれで問題かもしれない）、保守性・拡張性が悪くなるという問題と、容量の問題が生まれる。</p>

<p>保守性と拡張性が悪くなるというのは、具体的には<strong>スキーマ変更や値の整合性検査用のスクリプトが複雑化するということ</strong>ということ。一見SQLより楽そうだが、スキーマが自由であるがゆえに、nilなどが予期せず混入していたり、あるはずのキーがなかったりして、イテレータと分岐だらけのスクリプトになる可能性がある。ただ、これはインサート時に適切なマッパーを使ってvalidateするなどで対応できるかもしれない。</p>

<p>容量の問題も結構重要で、実は<a href="http://www.mongodb.org/display/DOCS/Documents">ドキュメント毎の容量が16MBという制限</a>がある様子。ブログの本文などを埋め込み方式のドキュメントに追記して管理するような構造だと、早晩これに引っかかるんだろう。</p>

<blockquote><p>ランキングサイトのように、1ページで多数のクエリを投げるような構造の場合、これらの問題が顕在化する。</p></blockquote>

<p>これがこの記事の結論で、具体的には<strong>1アクセス毎に数十個超のクエリを投げ、その結果がキャッシュできないページの場合や、集計等のバッチ処理が問題になると思う。</strong>クエリの質よりも数が、RDBMSに比べて問題になりやすいと言い換えてもいいかもしれない。</p>

<p>例えばクックパッドのように、ある人のある料理を表示し、自分のお気に入りの情報を表示し、ちょこっとランキングを乗せる程度なら問題にならないと思う。アカウント管理にMongoid等のマッパー経由で使っても、やはり速度面では問題にならないと思う。リレーションを含めた全体のクエリの個数も限られるから。でも、「対象を固定しない100個の要素を表示して、任意に並び替えができる検索結果ページ」なんてことになると、キャッシュもできず問題があらわになる。僕のサイトで参照方式と埋め込み方式の比較を行ったところ、5~8倍程度の実行時間の差が出てしまった。</p>

<p>また、集計などのバッチ処理をRubyでしようと思ったら、もうこの問題は避けられない。僕は毎晩4万件超を対象にしたバッチ処理を行なっているが、<strong>数千の処理ごとに数分間沈黙する。</strong>たぶん、GCがメルトダウンするぐらい仕事してるんだと思う。</p>

<p>ただ、集計に関してはバルクインサートを上手く使えばいいんだろうと思う。また、MongoDBにJavaScriptを読み込ませて実行すれば、若干は速くなるんだろう。ここらへんも実験してないので分からない。</p>

<blockquote><p>でもやっぱりMongoDBかわいいよMongoDB</p></blockquote>

<p>そうは言っても、MongoDBはとっつきやすいし、JSONっぽく操れて楽しいよ！</p>

    </article>
    
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_identifier = disqus_identifier && 'badid' || '';
      (function() {
       var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
       dsq.src = 'http://hd-mon.disqus.com/embed.js';
       (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=hd-mon">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    
    <em>Updated at  </em>
  </div>


  <footer>
    <p id="back_to_home">
      <a href="/">
        Back
      </a>
    </p>
    <div id="hashi"></div>
  </footer>

  <script type="text/javascript">
  var disqus_shortname = 'hd-mon';
  (function () {
    var s = document.createElement('script'); s.async = true;
    s.src = 'http://disqus.com/forums/hd-mon/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
  </script>

    <!-- jquery -->
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>  

  <!-- highlighter -->
  <script src="/vendor/highlight/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-23566516']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</body>
</html>
