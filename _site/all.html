<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>All Posts </title>

  
  <link rel="stylesheet" type="text/css" href="/style-others.css" media="screen" />
  
  
  <!-- jquery -->
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>  

  <!--- webputty -->
<link rel="stylesheet" type="text/css" href="http://www.webputty.net/css/agtzfmNzc2ZpZGRsZXIMCxIEUGFnZRiuhx0M" />
<script type="text/javascript">(function(w,d){if(w.location!=w.parent.location||w.location.search.indexOf('__preview_css__')>-1){var t=d.createElement('script');t.type='text/javascript';t.async=true;t.src='http://www.webputty.net/js/agtzfmNzc2ZpZGRsZXIMCxIEUGFnZRiuhx0M';(d.body||d.documentElement).appendChild(t);}})(window,document);</script>
  <script src="/vendor/highlight/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '___YOUR_UA_HERE___']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</head>

<body>
  <header>
    <hgroup>
      <div id="title-border"></div>
      <div id="title-logo" class="sprites index-titlelogo"></div>
      <div id="title-icon" class="sprites index-titleicon"></div>
      <ul>
        <li>twitter: <a href="https://twitter.com/#!/h_demon">@h_demon</a></li>
        <li>mail: hdemon7@gmail.com</li>
        <li>GitHub: <a href="https://github.com/hdemon">https://github.com/hdemon</a></li>
      </ul>
      <div id="title-border-bottom"></div>
    </hgroup>
  </header>

    <h2>Post Titles:</h2>
<ul>

  <li><a href="#/articles/corss-domain.html">Corss-domain</a></li>

</ul>



<h2>All Posts:</h2>
</div>

  <div><a name="/articles/corss-domain.html">&nbsp;</a>
    <h1>クロスドメインにまつわるヘッダについて考える。</h1>

<p> Chrome Extensionを開発中に、クロスドメイン通信を制約するヘッダにまつわるエラーに遭遇しました。、クロスドメイン通信に関して基本から学び直そうと調べる必要が出たので、せっかくなのでまとめました。</p>

<p>　以下の文章は私が個人的に調べた事をまとめたものであり、正しさの保障はありません。むしろ間違いを見つけたら、指摘して頂けるとありがたいです。</p>

<h2>なぜクロスドメイン通信が制約されるのか</h2>

<p>まずは基本から。
ブラウザ上のスクリプトが行うクロスドメイン通信には、ご存知の通り制約があります。でも考えてみれば、あるサーバがドメインの異なる別のサーバ間へリクエストすることは一般的な事、というより、それ自体がインターネットの機能を成している根幹要素であり、基本的にはそれを許可しなければ成り立ちません。許可したくない場合にのみ、IPやパスワード認証等で拒絶するというスタンスです。
ということは、「ブラウザ上スクリプトのクロスドメイン通信」と称してわざわざサーバ間通信と区別するのは、ブラウザを用いた通信に各種認証手続きやIPフィルタのみでは対応しきれない特殊なリスクがあるからだと言えます。そしてそれは、</p>

<ul>
<li>サーバ間の通信は、クライアントとなる側が自らあるいは信頼した第三者のスクリプトによって、自発的にリクエストする。</li>
<li>しかし、ブラウジングはその性質上、閲覧した時点でほぼ自動的にページに埋め込まれたスクリプトも実行される。</li>
<li>つまり、「他人の作った悪意のあるスクリプトを」「事前の調査なく」「半自動的に」実行してしまう可能性がある。</li>
</ul>


<p>という点だと思われます。
ただ、これらのリスクが存在するからといって、実行前にスクリプトの内容をいちいちユーザに確認させるようでは、利便性が大幅に損なわれブラウジングの意味が無くなります。そこで、半自動的に実行してしまうのはやむを得ないとしながら、それによって生まれるリスクをなるべく抑えるというアプローチを採っています（もちろん、ブラウザやその設定によっては、事前にユーザに確認をさせるでしょう）。それがクロスドメイン通信の制約…だと思います。</p>

<h2>具体的に、どんなリスクが生まれるのか。</h2>

<p>この項はちょっと知識と理解に自信がありません。しかし、調べた限りでは「クロスサイトスクリプティング（以下XSS)のバリエーションを増やす」、「DoS攻撃の踏み台に利用される」という2つのリスクが重要なんじゃないかと思います。以下簡単な解説。</p>

<h3>XSS</h3>

<p>不特定多数の人間が文字のメッセージを残せる掲示板やCMS等に、文章の代わりにタグを用いたJavaScript等のスクリプトを記述すると、そのサイトがスクリプトとして働く文字列を排除するロジックを持っていなければ、閲覧者のブラウザ上でそのスクリプトが動作し始めることになる。
この事自体はクロスドメイン通信の可否とは無関係に発生するが、それを許可してしまうとXSSをより効果的にしてしまう。具体的には、XSSによってCookie・キーイベント・DOM等から窃取したアカウント情報等を、さらに特定のサーバへ直接送信することが可能になり、XSSの目的をより直接的・効果的に達成する手段を与えることになる。</p>

<h3>DoS攻撃</h3>

<p>ページに特定／不特定のサーバへ短期間の連続アクセスをするスクリプトを記述することで、閲覧者にサーバ攻撃の肩代わりをさせることが可能になる。この場合、アクセス元はスクリプトを置いてあるサーバではなくクライアントのIPになるため、攻撃を意図した者には非常に都合がいい（ただ、後述するXHR Level2ではサーバがレスポンスを正常に返し得るため、サーバに負荷を掛けるだけなら何の障害もなくできてしまいますよね。）。</p>

<p>というわけで、これらのリスクを減らすため、ブラウザ上で動作するスクリプトの機能を制限するルールとして「同一生成元ポリシー」"same origin policy" が設けられました。</p>

<h2>同一生成元ポリシーとは？</h2>

<p>サイト上のスクリプトがあるサーバへデータをリクエストする命令を出した場合、そのサイトとリクエスト先とで、</p>

<ul>
<li>ホスト</li>
<li>ポート</li>
<li>プロトコル</li>
</ul>


<p>の全てが一致しない限り、リクエストを有効にしないというブラウザ上の制約です。このルールはNetscape2.0が独自に実装したことに始まり、その効果が認知され他の主要ブラウザでも採用されるようになりました。W3C等により共通仕様とされているわけではないですが、現在ブラウザとして認知される一般的なものは当然にこのポリシーを採用しています。</p>

<p>　そして、HTML5の勧告では"Cross-Origin Resource Sharing"（以下CORS)というセクションで、同一生成元ポリシーがより具体的な仕様として定められています（ただし、CORSは"non-normative"とされているので、この仕様を実装するかどうかは「W3C準拠」とは関係ないはずです）。</p>

<h2>クロスドメイン通信禁止の例外と、XMLHttpRequest</h2>

<p>　しかし、クロスドメイン通信を直接／間接的に可能にする方法がいくつか存在します。</p>

<ul>
<li>XMLHttpRequest Level2 / XDomainRequest を使う。</li>
<li>JSONPを使う。</li>
<li>プロキシを使う。</li>
</ul>


<p>1は前者がW3Cが策定中の共通仕様であり、後者はIEの独自機能。どちらも、クロスドメイン通信を行う正規の手段です。リクエスト／レスポンスヘッダを主な基準としたCORSの条件（XDomainRequestはやはり独自基準）をパスした場合にのみ、最終的にユーザがデータへアクセスすることを可能にします。
2は、$lt;scirpit&gt;タグで外部のスクリプトが読み込める事を利用した、クロスドメイン制限回避の例外的手法です。リクエスト先のサーバがJSONPの形でデータを返す機構を備えていることが条件です。
3は、第三のサーバを中継し直接的にはサーバ間の通信とすることで、同一生成元ポリシーの対象から外れる手法。当然、中継する機能を持ったサーバが必要です。</p>

<p>ここでXMLHttpRequestについてまとめておくと、</p>

<ul>
<li>XMLHttpRequest Level1と同一生成元ポリシーは共通仕様ではなく、具体的な実装や細かい条件はブラウザによって異なる。</li>
<li>XMLHttpRequest Level2はW3Cの共通仕様である。したがって、必ず実装すべき仕様と、裁量に任される部分が分かれる。</li>
<li>XMLHttpRequest Level2は、CORSのルールに従う。これは同一生成元ポリシーと根本的な趣旨を同じくするが、クロスドメイン通信を許可するための条件がより具体的で複雑化している。</li>
<li>ブラウザにXMLHttpRequest Level1とLevel2の２つのメソッドが同居するのではなく、Level2に置き換わる。つまり、Level2に準拠する限り、XMLHttpRequestはCORSのルールに従う。</li>
<li>ただし、XMLHttpRequest Level2とCORSとHTML5は独立したセクションであり、かつ現時点（2011/5)では全てドラフトであり、また前二者は"non-normative"である。</li>
</ul>


<p><a href="%E4%BB%95%E6%A7%98%E6%9B%B8">http://www.w3.org/TR/cors/#cross-origin-request</a></p>

<p>という感じです。つまり、クロスドメイン通信の制約についてはまだ多くがブラウザ側の裁量に任されており、各社のブラウザがどのように対応しているかは、個別に調べるか実験してみるかでしか判断できません。ちなみにW3Cにおける"non-normative"とか"SHOULD"などの言葉には厳密な定義があるので、是非読んでみてください。</p>

<h2>CORSの中核、Access-Control-Allow-OriginヘッダとOriginヘッダ</h2>

<p>Level2では、クロスドメイン通信は条件付きで許可されます。そしてその条件に合致しているかどうかは、主にリクエストヘッダとレスポンスヘッダによって判断されるようです（また、クロスドメイン通信が可能かどうかをサーバ側に問い合わせる、"preflight request"という予備的な通信を行う場合も規定されている）。</p>

<p>どういう事かというと、Level2の場合は「こちら側の身元をリクエストヘッダで明らかにした上で、とりあえずリクエストしてみる」ということを行います。それに対し、サーバ側はヘッダを見てデータを返さないということもできるが、「どのような場合にデータをユーザまで渡すことを許可するか」というヘッダをデータと一緒に返すこともできます。つまり、リクエスト自体は禁止せずに、正常に返ってきたレスポンスをブラウザが検閲して、それをユーザに渡すかどうかをヘッダによって決めるということです。</p>

<p>そのヘッダにはいくつか種類がありますが、「Access-Control-Allow-Origin レスポンスヘッダ」と「Origin リクエストヘッダ」が主要な役割を担うと思われます。これらのヘッダについて、次のようなルールが設けられています。</p>

<p>  Access-Control-Allow-Origin ヘッダに"*"が含まれるときは、クロスドメイン通信を許可する。
  Access-Control-Allow-Origin ヘッダが１つもないか、あるいは複数存在するときは不許可。
  Access-Control-Allow-Origin がOriginヘッダと一致しない場合も不許可。</p>

<p>※credential flag等の条件があるが、ややこしくなるので省略。
「許可する」というのは、繰り返しになるが「リクエストを送らない」ということではなく、ユーザにデータを受け渡さないということ。仕様書では、リクエストが返ってきたときの処理に関して、</p>

<p>6.1.5. Cross-Origin Request with Preflight<br/>
This is the actual request. Apply the make a request steps and observe the request rules below while making the request. If the response has an HTTP status code of 301, 302, 303, or 307 Apply the cache and network error steps. ... Otherwise Perform a resource sharing check. If it returns fail, apply the cache and network error steps. Otherwise, if it returns pass, terminate this algorithm and set the cross-origin request status to success. Do not actually terminate the request.
　Preflightを伴うクロスオリジンリクエスト
　もし、レスポンスが301、302、303、307のいずれかのHTTPステータスコードならば、</p>

<p>6.1.2. Cross-Origin Request Status
Each cross-origin request has an associated cross-origin request status that CORS API specifications that enable an API to make cross-origin requests can hook into. It can take at most two distinct values over the course of a cross-origin request. The values are: preflight complete The user agent is about to make the actual request. success The resource can be shared. abort error The user aborted the request.</p>

<p>このように書いており、resourceをユーザにshareするかどうかは、レスポンスが返ってきてから判断するとされていることが分かります。</p>

<h3>サーバは期待通りレスポンスするが、ブラウザが検閲して見せてくれないことの証拠</h3>

<p>以下については、Chrome 11 / Firefox 4 / Safari 5 で確認しました。Opera 11とIE9では再現できていません。
本当にそうなのかをちょっと実験してみます。XMLHttpRequestを利用して、あえて不可能なクロスドメインリクエストをてみるのです。仕様書によればリクエスト自体は許可されますから、そのリクエストが正常ならばサーバも正常なレスポンスをし、OSのレベルではそれを受け取れるはずです。これをプロトコル監視ツールのFiddlerを使って確認します。</p>

<p>例えば、次のようなTwitterのTLを取得するAPIへアクセスするスクリプトを実行したとする。</p>

<p>var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(){</p>

<pre><code>if (xhr.readyState === 4) console.log(xhr.responseText);
</code></pre>

<p>};
xhr.open("GET", "http://api.twitter.com/1/statuses/user_timeline.json?screen_name=h_demon", true);
xhr.send();
すると、コンソールにはこう表示される（Chromeの場合）。
XMLHttpRequest cannot load http://search.twitter.com/search.json?q=h_demon&amp;amp;amp;callback=?. Origin http://hdemon.net is not allowed by Access-Control-Allow-Origin.
「あなたのドメインは、Access-Control-Allow-Originによって許可されていないよ」と出る。
しかし、プロトコル監視ツールを使ってリクエストとレスポンスを見てみると、
GET http://search.twitter.com/search.json?q=h_demon&amp;callback=? HTTP/1.1
Host: search.twitter.com
Connection: keep-alive
Referer: http://hdemon.net/
Origin: http://hdemon.net
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24
Accept: <em>/</em>
HTTP/1.1 200 OK
Server: hi
Status: 200 OK
Content-Type: application/json; charset=utf-8
 Connection: close
 {"results":[{"from_user_id_str":"12345678","profile_image_url":....</p>

<p>…と、このようにちゃんと欲しいデータは返ってきている。ただし、リクエストヘッダにOriginヘッダが付いており、またAccess-Control-Allow-Originヘッダが無いため、ブラウザが検閲を行ってデータをユーザに渡さないのでしょう。ちなみに、JSONPを使ってTLを取得したときは、
var url = "http://api.twitter.com/1/statuses/user_timeline.json?screen_name=h_demon&amp;callback=?";
$.getJSON(url, null, function(json) {
  for(var i=0, l=json.results.length;</p>

<p>GET http://search.twitter.com/search.json?callback=jQuery....&amp;q=jquery&amp;_=1306207289145 HTTP/1.1
Host: search.twitter.com
Connection: keep-alive
Referer: http://hdemon.net/
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24
Accept: <em>/</em>
Accept-Encoding: gzip,deflate,sdch
Accept-Language: ja,en;q=0.8
Accept-Charset: Shift_JIS,utf-8;q=0.7,*;q=0.3</p>

<p>このようなリクエストヘッダになり、Originヘッダは付いていないことが分かります。</p>

<h2>制限すべき通信かどうかを、ブラウザはいつどうやって判断してるの？</h2>

<p>しかし、どうしてJSONPはクロスドメイン可能で、XMLHttpRequestはダメなのでしょうか。ブラウザ内部でクロスドメインの許可不許可を決定するパラメータがあるんじゃないか。だって、そもそもJSONPは広義のクロスドメイン通信であるのにも関わらず、リクエストにはOriginヘッダが付いておらず、またレスポンスにもAccess-Control-Allow-Originヘッダは付いていない。そうでありながら、通信は問題なく行われているわけだから。
そこでCORSの仕様書を読み進めると、このようにある。
3.1. Origin and Base URL
Each XMLHttpRequest object has an associated XMLHttpRequest origin and an XMLHttpRequest base URL.</p>

<p>3.6.8. The send() method
 If the XMLHttpRequest origin and the request URL are same origin ...These are the same-origin request steps.
 Otherwise These are the cross-origin request steps.</p>

<p>つまり、制約すべき「クロスドメイン通信」かどうかは、XMLHttpRequestのsendメソッドが呼ばれた時点で判断しているらしい。
 そして、とりあえずリクエストを送ってから上述のヘッダで判断するのではなく、originパラメータによって、リクエストする前にここで言うところの"cross-origin"か否かを判断しているらしい。"cross-origin"と認定されると、Access-Control-Requestヘッダ群を生成するために必要ないくつかのパラメータをcross-originプロセスへ渡すようだ。
そして、このルールが&lt;script&gt;
タグについても課せられるという記述はない。ただ、&lt;script type="text/javascript"&gt;
タグがJSONPに利用できると明記した箇所も今のところ見つかっていない。どちらも私が斜め読みした限りだが（参考：HTML5仕様書scriptタグ部分）。]]>&lt;/conte</p>

  </div>

</div>



<div class="footer">
  Page generated: 04 Oct 2011
</div>


  <footer></footer>

  <script type="text/javascript">
  var disqus_shortname = '___YOUR_ID_HERE___';
  (function () {
    var s = document.createElement('script'); s.async = true;
    s.src = 'http://disqus.com/forums/___YOUR_ID_HERE___/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
  </script>
</body>
</html>
